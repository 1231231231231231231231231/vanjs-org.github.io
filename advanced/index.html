<!DOCTYPE html>
<html><head>
    <link rel="icon" href="/logo.svg">
    <title>VanJS - Advanced Topics</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/w3.css">
    <link rel="stylesheet" href="/font.css">
    <link rel="stylesheet" href="/prism.css">
    <link rel="stylesheet" href="/vanjs.css">
  </head>
  <body class="line-numbers" data-prismjs-copy="üìã">
    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q0NB75RY7E"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Q0NB75RY7E');
    </script>
    <!-- Sidebar/menu -->
    <nav class="w3-sidebar w3-red w3-collapse w3-top w3-large w3-padding" style="z-index:3;width:280px;font-weight:bold;" id="mySidebar"><br>
      <a href="javascript:void(0)" onclick="w3_close()" class="w3-button w3-hide-large w3-display-topleft" style="width:100%;font-size:22px">Close Menu</a>
      <div class="w3-container">
        <h1 class="w3-padding-16 w3-xxxlarge">
          <img src="/logo.svg" alt="VanJS" width="192px" height="192px">
        </h1>
      </div>
      <div id="nav" class="w3-bar-block"><a href="/" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Home</a><a href="/start" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Getting Started</a><a href="/tutorial" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Tutorial</a><a href="/demo" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">VanJS by Example</a><a href="/convert" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Convert HTML to VanJS</a><a href="/minivan" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Mini-Van</a><a href="/advanced" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white current">Advanced Topics</a><a href="/media" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Media Mentions</a><a href="/about" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">About</a></div>
    </nav>

    <!-- Top menu on small screens -->
    <header class="w3-container w3-top w3-hide-large w3-red w3-xlarge w3-padding">
      <a href="javascript:void(0)" class="w3-button w3-red w3-margin-right" onclick="w3_open()">‚ò∞</a>
      <span id="title-bar">Advanced Topics</span>
    </header>

    <!-- Overlay effect when opening sidebar on small screens -->
    <div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

    <!-- !PAGE CONTENT! -->
    <div class="w3-main" style="margin-left:300px;">
      <div id="page">
        <div id="content"><h1 class="w3-xxlarge"><b>VanJS</b>: Advanced Topics</h1><h2 class="w3-xxlarge w3-text-red" id="dom-attributes-vs-properties"><a class="self-link" href="#dom-attributes-vs-properties">DOM Attributes vs. Properties</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>In <code class="symbol"><a href="/tutorial#api-tags" class="w3-hover-opacity">tag functions</a></code>, while assigning values from <code class="symbol">props</code>&nbsp;parameter to the created HTML element, there are 2 options of doing it: via <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes" class="w3-hover-opacity">HTML attributes</a></code> (<code class="language-js">dom.setAttribute(&lt;key&gt;, &lt;value&gt;)</code>), or via the properties of the created HTML element (<code class="language-js">dom[&lt;key&gt;] = &lt;value&gt;</code>). <b>VanJS</b> follows a consistent rule that makes sense for most use cases regarding which option to choose: when a settable property exists in a given <code class="symbol">&lt;key&gt;</code> for the specific element type, we will assign the value via property, otherwise we will assign the value via attribute.</p><p>For instance, <code class="language-js">input({type: "text", value: "Hello üç¶VanJS"})</code> will create an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text" class="w3-hover-opacity">input box</a> with <code class="symbol">Hello üç¶VanJS</code> as the value of the <code class="symbol">value</code> property, while <code class="language-js">div({"data-index": 1})</code> will create the tag: <code class="language-html">&lt;div data-index="1"&gt;&lt;/div&gt;</code>.</p><p>Note that, for readonly properties of HTML elements, we will still assign <code class="symbol">props</code> values via <code class="symbol">setAttribute</code>. For instance, in the code snippet below, the <code class="symbol">list</code> of the <code class="symbol">&lt;input&gt;</code> element is set via <code class="symbol">setAttribute</code>:</p><pre><code class="language-js">const Datalist = () =&gt; div(
  label({for: "ice-cream-choice"}, "Choose a flavor: "),
  input({
    list: "ice-cream-flavors",
    id: "ice-cream-choice",
    name: "ice-cream-choice",
  }),
  datalist(
    {id: "ice-cream-flavors"},
    option({value: "Chocolate"}),
    option({value: "Coconut"}),
    option({value: "Mint"}),
    option({value: "Strawberry"}),
    option({value: "Vanilla"}),
  )
)
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/readonly-prop">Try on jsfiddle</a></p><h2 class="w3-xxlarge w3-text-red" id="why-not-dom-valued-states"><a class="self-link" href="#why-not-dom-valued-states">Why Can't States Have DOM Node as Values?</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>We might be prompted to assign a DOM node to a <code class="symbol">State</code> object, especially when the <code class="symbol">State</code> object is used as a <code class="symbol">State</code>-typed child. However, this is problematic when the state is bound to multiple child DOM nodes, like the example below:</p><pre><code class="language-js">const {b, button, span} = van.tags

const TurnBold = () =&gt; {
  const vanJS = van.state("VanJS")
  return span(
    button({onclick: () =&gt; vanJS.val = b("VanJS")}, "Turn Bold"),
    "&nbsp;Welcome to ", vanJS, ". ", vanJS, "&nbsp;is awesome!"
  )
}

van.add(document.body, TurnBold())
</code></pre><p><b>Demo:</b> <span id="demo-dom-valued-state"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/dom-valued-state">Try on jsfiddle</a></p><p>In this example, if we click the "Turn Bold" button, the first "<b>VanJS</b>" text will disappear, which is unexpected. This is because the same DOM node is used twice in the DOM tree. For this reason, an error will be thrown in <code class="symbol">van-{version}.debug.js</code> whenever we assign a DOM node to a <code class="symbol">State</code> object.</p><h2 class="w3-xxlarge w3-text-red" id="gc"><a class="self-link" href="#gc">Garbage Collection</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>There is garbage collection mechanism implemented in <b>VanJS</b> to recycle obsolete state bindings. To illustrate the necessity of garbage collection, let's take a look at the code below:</p><pre><code class="language-js">const renderPre = van.state(false)
const text = van.state("Text")
const Text = () =&gt; div(
  () =&gt; (renderPre.val ? pre : span)(text),
)
</code></pre><p>In this piece of code, the <code class="symbol">Text</code> component has a <code class="symbol">&lt;div&gt;</code> element whose only child binds to a <code class="symbol">boolean</code> state - <code class="symbol">renderPre</code>, which determines whether the <code class="symbol">&lt;div&gt;</code> has a <code class="symbol">&lt;pre&gt;</code> or <code class="symbol">&lt;span&gt;</code> child. Inside the child element, the underlying text binds to a <code class="symbol">string</code> state - <code class="symbol">text</code>. Whenever the value of <code class="symbol">renderPre</code> is toggled, a new version of the <code class="symbol">&lt;div&gt;</code> element will be generated, and we will add a new binding from <code class="symbol">text</code> state to the child text node of the newly created <code class="symbol">&lt;div&gt;</code> element.</p><p>Without proper garbage collection implemented, <code class="symbol">text</code>&nbsp;state will be eventually bound to many text nodes after <code class="symbol">renderPre</code> is toggled many times. All the of bindings, except for the most recently added one, are actually obsolete, as they bind the <code class="symbol">text</code> state to a text node that is not currently being used. i.e.: disconnected from the document tree. Meanwhile, because internally, a <code class="symbol">State</code>&nbsp;object holds the reference to all DOM elements that bind to it, these DOM elements won't be GC-ed by JavaScript runtime, causing <a href="https://en.wikipedia.org/wiki/Memory_leak" class="w3-hover-opacity">memory leaks</a>.</p><p>Garbage collection is implemented in <b>VanJS</b>&nbsp;to resolve the issue. There are 2 ways a garbage collection activity can be triggered:</p><ol><li><b>Periodic recycling:</b> periodically, <b>VanJS</b>&nbsp;will scan all <code class="symbol">State</code> objects that have new bindings added recently, and remove all the bindings for a disconnected DOM element. i.e.: <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" class="w3-hover-opacity">isConnected</a></code>&nbsp;property is <code class="symbol">false</code>.</li><li><b>Pre-rendering recycling:</b> before <b>VanJS</b> re-render the DOM tree in response to state changes, it will first check all the states whose values have been changed in this render cycle, and remove all the bindings for a disconnected DOM element.</li></ol><p><a href="/code/gc-ui" class="w3-hover-opacity">Try out the example here</a> (You can use developer console to watch <code class="symbol">renderPre</code>'s UI bindings).</p><h3 class="w3-large w3-text-red" id="avoid-your-bindings-to-be-gc-ed-unexpectedly"><a class="self-link" href="#avoid-your-bindings-to-be-gc-ed-unexpectedly">Avoid your bindings to be GC-ed unexpectedly</a></h3><p>There are some general guidelines to follow to avoid your bindings being garbage collected unexpectedly:</p><ol><li>Please complete the construction of the DOM tree and connect the newly constructed DOM tree to the <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/document" class="w3-hover-opacity">document</a></code> object before making any state changes. Otherwise, the bindings to yet-to-be-connected DOM elements will be garbage collected.</li><li>DOM tree construction needs to be synchronous. i.e.: you shouldn't have any suspension point while building the DOM tree (e.g.: <code class="symbol">await</code> something in an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" class="w3-hover-opacity">async function</a></code>). Otherwise, periodic recycling might be scheduled in the middle of the suspension point which can cause bindings to yet-to-be-connected DOM elements being garbage collected.</li></ol><h3 class="w3-large w3-text-red" id="derived-states-and-side-effects-are-not-subject-to-gc"><a class="self-link" href="#derived-states-and-side-effects-are-not-subject-to-gc">Derived states and side effects are not subject to GC</a></h3><p>Note that, the garbage collection in <b>VanJS</b> only removes obsolete UI bindings. It doesn't apply to derived states or side effects registered via <code class="symbol">van.derive</code>. For instance, the code below still suffers from memory leaks:</p><pre><code class="language-js">const renderPre = van.state(false)
const prefix = van.state("Prefix - ")
return div(() =&gt; {
  const suffix = van.state("Suffix")
  const text = van.derive(() =&gt; `${prefix.val}${suffix.val}`)
  return (renderPre.val ? pre : span)(text)
})
</code></pre><p>In this example, whenever <code class="symbol">renderPre</code> is toggled, a new <code class="symbol">text</code> state will be created and subscribe to changes of the <code class="symbol">prefix</code> and <code class="symbol">suffix</code> state. Because <code class="symbol">prefix</code> is defined in the outer scope, it will eventually hold references to many versions of the derived <code class="symbol">text</code> state, which are created whenever the binding function is called. These <code class="symbol">text</code> state instances won't be GC-ed by JavaScript runtime even though they're no longer being used except for the most recent one.</p><p>To avoid memory leaks in this situation, if you register derived states or side effects via <code class="symbol">van.derive</code> inside a binding function, the derived states or side effect shall NEVER depend on state that are created outside the scope of current binding function. The code above can be modified in the following way:</p><pre><code class="language-js">const renderPre = van.state(false)
const prefix = van.state("Prefix - ")
return div(() =&gt; {
  const prefixVal = prefix.val
  const suffix = van.state("Suffix")
  const text = van.derive(() =&gt; `${prefixVal}${suffix.val}`)
  return (renderPre.val ? pre : span)(text)
})
</code></pre><p>In the modified implementation above, we're making the <code class="symbol">State</code>-derived DOM node, instead of the <code class="symbol">text</code> state, depend on the <code class="symbol">prefix</code> state, which avoids the GC issue.</p><p>In <code class="symbol">van-{version}.debug.js</code>, an error will be thrown if you try to reference a state created out of the scope of the current binding function while defining derived states or side effects.</p></div>
        <aside id="toc"><ul><li><a href="#dom-attributes-vs-properties" class="w3-hover-opacity">DOM Attributes vs. Properties</a></li><li><a href="#why-not-dom-valued-states" class="w3-hover-opacity">Why Can't States Have DOM Node as Values?</a></li><li><a href="#gc" class="w3-hover-opacity">Garbage Collection</a><ul><li><a href="#avoid-your-bindings-to-be-gc-ed-unexpectedly" class="w3-hover-opacity">Avoid your bindings to be GC-ed unexpectedly</a></li><li><a href="#derived-states-and-side-effects-are-not-subject-to-gc" class="w3-hover-opacity">Derived states and side effects are not subject to GC</a></li></ul></li></ul></aside>
      </div>
    </div>
    <script>
      // Script to open and close sidebar
      const w3_open = () => {
        document.getElementById("mySidebar").style.display = "block"
        document.getElementById("myOverlay").style.display = "block"
      }

      const w3_close = () => {
        document.getElementById("mySidebar").style.display = "none"
        document.getElementById("myOverlay").style.display = "none"
      }

      const tocDom = document.getElementById("toc")

      // Track the current toc item
      const trackToc = () => {
        const allHeadings = [...document.querySelectorAll("h2,h3")]
        const currentHeading = allHeadings.find(h => h.getBoundingClientRect().top >= 0)
          ?? allHeadings[allHeadings.length - 1]
        for (const e of document.querySelectorAll("#toc li a"))
          if (e.href.split("#")[1] === currentHeading?.id) {
            e.classList.add("w3-opacity")
            const {top: tocTop, bottom: tocBottom} = tocDom.getBoundingClientRect()
            const {top: eTop, bottom: eBottom} = e.getBoundingClientRect()
            if (eBottom > tocBottom) tocDom.scrollTop += eBottom - tocBottom
            else if (eTop < tocTop) tocDom.scrollTop -= tocTop - eTop
          } else
            e.classList.remove("w3-opacity")
      }
      trackToc()
      document.addEventListener("scroll", trackToc)
      addEventListener("resize", trackToc)
    </script>
    <script type="text/javascript" src="/prism.js"></script>
    <script type="module">{
  const {b, button, span} = van.tags

  const TurnBold = () => {
    const vanJS = van.state("VanJS")
    return span(
      button({onclick: () => vanJS.val = b("VanJS")}, "Turn Bold"),
      "¬†Welcome to ", vanJS, ". ", vanJS, "¬†is awesome!"
    )
  }

  van.add(document.getElementById("demo-dom-valued-state"), TurnBold())
}
</script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript" src="/code/diff.min.js"></script>
    <script type="text/javascript" src="/code/van-latest.nomodule.min.js"></script>
    <script>
      const copy = e => {
        const file = e.previousElementSibling.innerText
        const importLine = file.includes("nomodule") ?
          `<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"><\/script>` :
          `import van from "https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"`
          navigator.clipboard.writeText(importLine)
            .then(() => e.querySelector(".tooltip").innerText = "Copied")
            .catch(() => e.querySelector(".tooltip").innerText = "Copy failed")
      }

      const resetTooltip = e => e.querySelector(".tooltip").innerText = "Copy import line"
    </script>
    <script class="inline"></script>
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async="" defer="" src="https://buttons.github.io/buttons.js"></script>
  

</body></html>