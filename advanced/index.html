<!DOCTYPE html>
<html><head>
    <link rel="icon" href="/logo.svg">
    <title>VanJS - Advanced Topics</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/w3.css">
    <link rel="stylesheet" href="/font.css">
    <link rel="stylesheet" href="/prism.css">
    <link rel="stylesheet" href="/vanjs.css">
  </head>
  <body class="line-numbers" data-prismjs-copy="üìã">
    <!-- Google tag (gtag.js) -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q0NB75RY7E"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-Q0NB75RY7E');
    </script>
    <!-- Sidebar/menu -->
    <nav class="w3-sidebar w3-red w3-collapse w3-top w3-large w3-padding" style="z-index:3;width:280px;font-weight:bold;" id="mySidebar"><br>
      <a href="javascript:void(0)" onclick="w3_close()" class="w3-button w3-hide-large w3-display-topleft" style="width:100%;font-size:22px">Close Menu</a>
      <div class="w3-container">
        <h1 class="w3-padding-16 w3-xxxlarge">
          <img src="/logo.svg" alt="VanJS" width="192px" height="192px">
        </h1>
      </div>
      <div id="nav" class="w3-bar-block"><a href="/" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Home</a><a href="/start" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Getting Started</a><a href="/tutorial" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Tutorial</a><a href="/demo" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">VanJS by Example</a><a href="/convert" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Convert HTML to VanJS</a><a href="/minivan" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Mini-Van</a><a href="/advanced" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white current">Advanced Topics</a><a href="/media" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">Media Mentions</a><a href="/about" onclick="w3_close()" class="w3-bar-item w3-button w3-hover-white">About</a></div>
    </nav>

    <!-- Top menu on small screens -->
    <header class="w3-container w3-top w3-hide-large w3-red w3-xlarge w3-padding">
      <a href="javascript:void(0)" class="w3-button w3-red w3-margin-right" onclick="w3_open()">‚ò∞</a>
      <span id="title-bar">Advanced Topics</span>
    </header>

    <!-- Overlay effect when opening sidebar on small screens -->
    <div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

    <!-- !PAGE CONTENT! -->
    <div class="w3-main" style="margin-left:300px;">
      <div id="page">
        <div id="content"><h1 class="w3-xxlarge"><b>VanJS</b>: Advanced Topics</h1><h2 class="w3-xxlarge w3-text-red" id="dom-attributes-vs-properties"><a class="self-link" href="#dom-attributes-vs-properties">DOM Attributes vs. Properties</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>In <code class="symbol"><a href="/tutorial#api-tags" class="w3-hover-opacity">tag functions</a></code>, while assigning values from <code class="symbol">props</code>&nbsp;parameter to the created HTML element, there are 2 options of doing it: via <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes" class="w3-hover-opacity">HTML attributes</a></code> (<code class="language-js">dom.setAttribute(&lt;key&gt;, &lt;value&gt;)</code>), or via the properties of the created HTML element (<code class="language-js">dom[&lt;key&gt;] = &lt;value&gt;</code>). <b>VanJS</b> follows a consistent rule that makes sense for most use cases regarding which option to choose: when a settable property exists in a given <code class="symbol">&lt;key&gt;</code> for the specific element type, we will assign the value via property, otherwise we will assign the value via attribute.</p><p>For instance, <code class="language-js">input({type: "text", value: "Hello üç¶VanJS"})</code> will create an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/text" class="w3-hover-opacity">input box</a> with <code class="symbol">Hello üç¶VanJS</code> as the value of the <code class="symbol">value</code> property, while <code class="language-js">div({"data-index": 1})</code> will create the tag: <code class="language-html">&lt;div data-index="1"&gt;&lt;/div&gt;</code>.</p><p>Note that, for readonly properties of HTML elements, we will still assign <code class="symbol">props</code> values via <code class="symbol">setAttribute</code>. For instance, in the code snippet below, the <code class="symbol">list</code> of the <code class="symbol">&lt;input&gt;</code> element is set via <code class="symbol">setAttribute</code>:</p><pre><code class="language-js">const Datalist = () =&gt; div(
  label({for: "ice-cream-choice"}, "Choose a flavor: "),
  input({
    list: "ice-cream-flavors",
    id: "ice-cream-choice",
    name: "ice-cream-choice",
  }),
  datalist(
    {id: "ice-cream-flavors"},
    option({value: "Chocolate"}),
    option({value: "Coconut"}),
    option({value: "Mint"}),
    option({value: "Strawberry"}),
    option({value: "Vanilla"}),
  )
)
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/readonly-prop">Try on jsfiddle</a></p><h2 class="w3-xxlarge w3-text-red" id="state-and-state-binding"><a class="self-link" href="#state-and-state-binding">State and State Binding</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><h3 class="w3-large w3-text-red" id="why-not-dom-valued-states"><a class="self-link" href="#why-not-dom-valued-states">Why can't states have DOM node as values?</a></h3><p>We might be prompted to assign a DOM node to a <code class="symbol">State</code> object, especially when the <code class="symbol">State</code> object is used as a <code class="symbol">State</code>-typed child. However, this is problematic when the state is bound to multiple child DOM nodes, like the example below:</p><pre><code class="language-js">const {b, button, span} = van.tags

const TurnBold = () =&gt; {
  const vanJS = van.state("VanJS")
  return span(
    button({onclick: () =&gt; vanJS.val = b("VanJS")}, "Turn Bold"),
    "&nbsp;Welcome to ", vanJS, ". ", vanJS, "&nbsp;is awesome!"
  )
}

van.add(document.body, TurnBold())
</code></pre><p><b>Demo:</b> <span id="demo-dom-valued-state"></span></p><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/dom-valued-state">Try on jsfiddle</a></p><p>In this example, if we click the "Turn Bold" button, the first "<b>VanJS</b>" text will disappear, which is unexpected. This is because the same DOM node is used twice in the DOM tree. For this reason, an error will be thrown in <code class="symbol">van-{version}.debug.js</code> whenever we assign a DOM node to a <code class="symbol">State</code> object.</p><h3 class="w3-large w3-text-red" id="state-granularity"><a class="self-link" href="#state-granularity">State granularity</a></h3><p>Whenever possible, it's encouraged to define states at a more granular level. That is, it's recommended to define states like this:</p><pre><code class="language-js">const appState = {
  a: van.state(1),
  b: van.state(2),
}
</code></pre><p>instead of that:</p><pre><code class="language-js">const appState = van.state({
  a: 1,
  b: 2,
})
</code></pre><p>More granular <code class="symbol">State</code> objects can help state bindings be more locally scoped, which make reactive UI updates more effient by eliminating unnecessary DOM tree construction and replacement.</p><h3 class="w3-large w3-text-red" id="advanced-state-derivation"><a class="self-link" href="#advanced-state-derivation">Advanced state derivation</a></h3><p>A broad set of advanced state derivation (derived states and side effects) can indeed be defined with <code class="symbol"><a href="/tutorial#api-derive" class="w3-hover-opacity">van.derive</a></code>, as illustrated in the following piece of code:</p><pre><code class="language-js">const fullName = van.state("Tao Xin")

// Declaring multiple derived states
const firstName = van.state(), lastName = van.state()
van.derive(() =&gt; [firstName.val, lastName.val] = fullName.val.split(" "))

const elapsed = van.state(0)
setInterval(() =&gt; elapsed.val += .01, 10)

// Same as `elapsed`, but delay the state propagation by 1s
const delayed = van.state(0)
van.derive(() =&gt; setTimeout(v =&gt; delayed.val = v, 1000, elapsed.val))

// Same as `elapsed`, but throttle the state update to every 100ms
const throttled = van.state(0)
setInterval(() =&gt; throttled.val = elapsed.val, 100)

// Generate a data stream for all value updates of a given state `s`
const streamOf = s =&gt; {
  let resolver
  van.derive(() =&gt; resolver ? resolver({value: s.val, done: false}) : s.val)
  return {
    [Symbol.asyncIterator]: () =&gt; ({
      next: () =&gt; new Promise(resolve =&gt; resolver = resolve)
    })
  }
}

(async () =&gt; {
  // To subscribe the data stream
  for await (const v of streamOf(throttled)) {
    console.log("elapsed: ", v)
  }
  // You can also chain the data stream with `map`, `filter`, etc. by integrating with
  // wu.js (https://fitzgen.github.io/wu.js/)
})()
</code></pre><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/advanced-state-derivation">Try on jsfiddle</a></p><h3 class="w3-large w3-text-red" id="conditional-state-binding"><a class="self-link" href="#conditional-state-binding">Conditional state binding</a></h3><p>In <a href="/tutorial#state-derived-prop" class="w3-hover-opacity"><code class="symbol">State</code>-derived properties</a> and <a href="/tutorial#state-derived-child" class="w3-hover-opacity"><code class="symbol">State</code>-derived child nodes</a>, it is guaranteed that the binding function will be triggered, and only be triggered to generate the new UI content when the dependency states change. This is true even for complex binding functions, who have different dependency states under different conditions.</p><p>For instance, the binding function <code class="language-js">() =&gt; cond.val ? a.val + b.val : c.val + d.val</code> will be triggered and only be triggered by updates of state <code class="symbol">a</code> and <code class="symbol">b</code> if <code class="symbol">cond.val</code> is true, and will be triggered and only be triggered by updates of state <code class="symbol">c</code> and <code class="symbol">d</code> if <code class="symbol">cond.val</code> is false. This can be illustrated with the code below:</p><pre><code class="language-js">const ConditionalBinding = () =&gt; {
  const formula = van.state("a + b")
  const a = van.state(1), b = van.state(2), c = van.state(3), d = van.state(4)
  const triggeredTimes = new Text(0)

  return div(
    div(
      "formula: ",
      select({value: formula, oninput: e =&gt; formula.val = e.target.value},
        option("a + b"), option("c + d"),
      ),
      " a: ",
      input({type: "number", min: 0, max: 9, value: a, oninput: e =&gt; a.val = Number(e.target.value)}),
      " b: ",
      input({type: "number", min: 0, max: 9, value: b, oninput: e =&gt; b.val = Number(e.target.value)}),
      " c: ",
      input({type: "number", min: 0, max: 9, value: c, oninput: e =&gt; c.val = Number(e.target.value)}),
      " d: ",
      input({type: "number", min: 0, max: 9, value: d, oninput: e =&gt; d.val = Number(e.target.value)}),
    ),
    div("sum: ", () =&gt; {
      triggeredTimes.textContent = Number(triggeredTimes.textContent) + 1
      return formula.val === "a + b" ? a.val + b.val : c.val + d.val
    }),
    div("Binding function triggered: ", triggeredTimes, " time(s)"),
  )
}
</code></pre><p><b>Demo:</b></p><p id="demo-conditional-binding"></p><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/conditional-binding">Try on jsfiddle</a></p><p>Conditional state binding works for <a href="/tutorial#derived-state" class="w3-hover-opacity">derived states</a> and <a href="/tutorial#side-effect" class="w3-hover-opacity">side effects</a> registered via <code class="symbol">van.derive</code> as well:</p><pre><code class="language-js">const ConditionalDerive = () =&gt; {
  const formula = van.state("a + b")
  const a = van.state(1), b = van.state(2), c = van.state(3), d = van.state(4)
  const triggeredTimes = new Text(0)
  const sum = van.derive(() =&gt; {
    triggeredTimes.textContent = Number(triggeredTimes.textContent) + 1
    return formula.val === "a + b" ? a.val + b.val : c.val + d.val
  })

  return div(
    div(
      "formula: ",
      select({value: formula, oninput: e =&gt; formula.val = e.target.value},
        option("a + b"), option("c + d"),
      ),
      " a: ",
      input({type: "number", min: 0, max: 9, value: a, oninput: e =&gt; a.val = Number(e.target.value)}),
      " b: ",
      input({type: "number", min: 0, max: 9, value: b, oninput: e =&gt; b.val = Number(e.target.value)}),
      " c: ",
      input({type: "number", min: 0, max: 9, value: c, oninput: e =&gt; c.val = Number(e.target.value)}),
      " d: ",
      input({type: "number", min: 0, max: 9, value: d, oninput: e =&gt; d.val = Number(e.target.value)}),
    ),
    div("sum: ", sum),
    div("Binding function triggered: ", triggeredTimes, " time(s)"),
  )
}
</code></pre><p><b>Demo:</b></p><p id="demo-conditional-derive"></p><p><a href="https://jsfiddle.net/gh/get/library/pure/Tao-VanJS/jsfiddle-test/tree/master/jsfiddle/advanced/conditional-derive">Try on jsfiddle</a></p><h2 class="w3-xxlarge w3-text-red" id="gc"><a class="self-link" href="#gc">Garbage Collection</a></h2><hr style="width:50px;border:5px solid red" class="w3-round"><p>There is garbage collection mechanism implemented in <b>VanJS</b> to recycle obsolete state bindings. To illustrate the necessity of garbage collection, let's take a look at the code below:</p><pre><code class="language-js">const renderPre = van.state(false)
const text = van.state("Text")
const Text = () =&gt; div(
  () =&gt; (renderPre.val ? pre : span)(text),
)
</code></pre><p>In this piece of code, the <code class="symbol">Text</code> component has a <code class="symbol">&lt;div&gt;</code> element whose only child binds to a <code class="symbol">boolean</code> state - <code class="symbol">renderPre</code>, which determines whether the <code class="symbol">&lt;div&gt;</code> has a <code class="symbol">&lt;pre&gt;</code> or <code class="symbol">&lt;span&gt;</code> child. Inside the child element, the underlying text binds to a <code class="symbol">string</code> state - <code class="symbol">text</code>. Whenever the value of <code class="symbol">renderPre</code> is toggled, a new version of the <code class="symbol">&lt;div&gt;</code> element will be generated, and we will add a new binding from <code class="symbol">text</code> state to the child text node of the newly created <code class="symbol">&lt;div&gt;</code> element.</p><p>Without proper garbage collection implemented, <code class="symbol">text</code>&nbsp;state will be eventually bound to many text nodes after <code class="symbol">renderPre</code> is toggled many times. All the of bindings, except for the most recently added one, are actually obsolete, as they bind the <code class="symbol">text</code> state to a text node that is not currently being used. i.e.: disconnected from the document tree. Meanwhile, because internally, a <code class="symbol">State</code>&nbsp;object holds the reference to all DOM elements that bind to it, these DOM elements won't be GC-ed by JavaScript runtime, causing <a href="https://en.wikipedia.org/wiki/Memory_leak" class="w3-hover-opacity">memory leaks</a>.</p><p>Garbage collection is implemented in <b>VanJS</b>&nbsp;to resolve the issue. There are 2 ways a garbage collection activity can be triggered:</p><ol><li><b>Periodic recycling:</b> periodically, <b>VanJS</b>&nbsp;will scan all <code class="symbol">State</code> objects that have new bindings added recently, and remove all the bindings for a disconnected DOM element. i.e.: <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected" class="w3-hover-opacity">isConnected</a></code>&nbsp;property is <code class="symbol">false</code>.</li><li><b>Pre-rendering recycling:</b> before <b>VanJS</b> re-render the DOM tree in response to state changes, it will first check all the states whose values have been changed in this render cycle, and remove all the bindings for a disconnected DOM element.</li></ol><p><a href="/code/gc-ui" class="w3-hover-opacity">Try out the example here</a> (You can use <a href="https://en.wikipedia.org/wiki/Web_development_tools" class="w3-hover-opacity">developer console</a> to watch <code class="symbol">text</code>'s UI <code class="symbol">bindings</code>).</p><h3 class="w3-large w3-text-red" id="avoid-your-bindings-to-be-gc-ed-unexpectedly"><a class="self-link" href="#avoid-your-bindings-to-be-gc-ed-unexpectedly">Avoid your bindings to be GC-ed unexpectedly</a></h3><p>There are some general guidelines to follow to avoid your bindings being garbage collected unexpectedly:</p><ol><li>Please complete the construction of the DOM tree and connect the newly constructed DOM tree to the <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/document" class="w3-hover-opacity">document</a></code> object before making any state changes. Otherwise, the bindings to yet-to-be-connected DOM elements will be garbage collected.</li><li>DOM tree construction needs to be synchronous. i.e.: you shouldn't have any suspension point while building the DOM tree (e.g.: <code class="symbol">await</code> something in an <code class="symbol"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" class="w3-hover-opacity">async function</a></code>). Otherwise, periodic recycling might be scheduled in the middle of the suspension point which can cause bindings to yet-to-be-connected DOM elements being garbage collected.</li></ol><h3 class="w3-large w3-text-red" id="derived-states-and-side-effects-are-not-subject-to-gc"><a class="self-link" href="#derived-states-and-side-effects-are-not-subject-to-gc">Derived states and side effects are not subject to GC</a></h3><p>Note that, the garbage collection in <b>VanJS</b> only removes obsolete UI bindings. It doesn't apply to derived states or side effects registered via <code class="symbol">van.derive</code>. For instance, the code below still suffers from memory leaks:</p><pre><code class="language-js">const renderPre = van.state(false)
const prefix = van.state("Prefix - ")
const TextDiv = () =&gt; div(() =&gt; {
  const suffix = van.state("Suffix")
  const text = van.derive(() =&gt; `${prefix.val}${suffix.val}`)
  return (renderPre.val ? pre : span)(text)
})
</code></pre><p>In this example, whenever <code class="symbol">renderPre</code> is toggled, a new <code class="symbol">text</code> state will be created and subscribe to changes of the <code class="symbol">prefix</code> and <code class="symbol">suffix</code> state. Because <code class="symbol">prefix</code> is defined in the outer scope, it will eventually hold references to many versions of the derived <code class="symbol">text</code> state, which are created whenever the binding function is called. These <code class="symbol">text</code> state instances won't be GC-ed by JavaScript runtime even though they're no longer being used except for the most recent one.</p><p><a href="/code/gc-derive-bad" class="w3-hover-opacity">Try out the example here</a> (You can use developer console to watch <code class="symbol">prefix</code>'s <code class="symbol">listeners</code>).</p><p>To avoid memory leaks in this situation, if you register derived states or side effects via <code class="symbol">van.derive</code> inside a binding function, the derived states or side effect shall NEVER depend on state that are created outside the scope of current binding function. The code above can be modified in the following way:</p><pre><code class="language-js">const renderPre = van.state(false)
const prefix = van.state("Prefix - ")
const TextDiv = () =&gt; div(() =&gt; {
  const prefixVal = prefix.val
  const suffix = van.state("Suffix")
  const text = van.derive(() =&gt; `${prefixVal}${suffix.val}`)
  return (renderPre.val ? pre : span)(text)
})
</code></pre><p>In the modified implementation above, we're making the <code class="symbol">State</code>-derived DOM node, instead of the <code class="symbol">text</code> state, depend on the <code class="symbol">prefix</code> state, which avoids the GC issue.</p><p><a href="/code/gc-derive-good" class="w3-hover-opacity">Try out the example here</a> (You can use developer console to watch <code class="symbol">prefix</code>'s <code class="symbol">listeners</code>).</p><p>In <code class="symbol">van-{version}.debug.js</code>, an error will be thrown if you try to reference a state created out of the scope of the current binding function while defining derived states or side effects.</p></div>
        <aside id="toc"><ul><li><a href="#dom-attributes-vs-properties" class="w3-hover-opacity">DOM Attributes vs. Properties</a></li><li><a href="#state-and-state-binding" class="w3-hover-opacity">State and State Binding</a><ul><li><a href="#why-not-dom-valued-states" class="w3-hover-opacity">Why can't states have DOM node as values?</a></li><li><a href="#state-granularity" class="w3-hover-opacity">State granularity</a></li><li><a href="#advanced-state-derivation" class="w3-hover-opacity">Advanced state derivation</a></li><li><a href="#conditional-state-binding" class="w3-hover-opacity">Conditional state binding</a></li></ul></li><li><a href="#gc" class="w3-hover-opacity">Garbage Collection</a><ul><li><a href="#avoid-your-bindings-to-be-gc-ed-unexpectedly" class="w3-hover-opacity">Avoid your bindings to be GC-ed unexpectedly</a></li><li><a href="#derived-states-and-side-effects-are-not-subject-to-gc" class="w3-hover-opacity">Derived states and side effects are not subject to GC</a></li></ul></li></ul></aside>
      </div>
    </div>
    <script>
      // Script to open and close sidebar
      const w3_open = () => {
        document.getElementById("mySidebar").style.display = "block"
        document.getElementById("myOverlay").style.display = "block"
      }

      const w3_close = () => {
        document.getElementById("mySidebar").style.display = "none"
        document.getElementById("myOverlay").style.display = "none"
      }

      const tocDom = document.getElementById("toc")

      // Track the current toc item
      const trackToc = () => {
        const allHeadings = [...document.querySelectorAll("h2,h3")]
        const currentHeading = allHeadings.find(h => h.getBoundingClientRect().top >= 0)
          ?? allHeadings[allHeadings.length - 1]
        for (const e of document.querySelectorAll("#toc li a"))
          if (e.href.split("#")[1] === currentHeading?.id) {
            e.classList.add("w3-opacity")
            const {top: tocTop, bottom: tocBottom} = tocDom.getBoundingClientRect()
            const {top: eTop, bottom: eBottom} = e.getBoundingClientRect()
            if (eBottom > tocBottom) tocDom.scrollTop += eBottom - tocBottom
            else if (eTop < tocTop) tocDom.scrollTop -= tocTop - eTop
          } else
            e.classList.remove("w3-opacity")
      }
      trackToc()
      document.addEventListener("scroll", trackToc)
      addEventListener("resize", trackToc)
    </script>
    <script type="text/javascript" src="/prism.js"></script>
    <script type="module">{
  const {b, button, span} = van.tags

  const TurnBold = () => {
    const vanJS = van.state("VanJS")
    return span(
      button({onclick: () => vanJS.val = b("VanJS")}, "Turn Bold"),
      "¬†Welcome to ", vanJS, ". ", vanJS, "¬†is awesome!"
    )
  }

  van.add(document.getElementById("demo-dom-valued-state"), TurnBold())
}

{
  const {div, input, option, select} = van.tags

  const ConditionalBinding = () => {
    const formula = van.state("a + b")
    const a = van.state(1), b = van.state(2), c = van.state(3), d = van.state(4)
    const triggeredTimes = new Text(0)

    return div(
      div(
        "formula: ",
        select({value: formula, oninput: e => formula.val = e.target.value},
          option("a + b"), option("c + d"),
        ),
        " a: ",
        input({type: "number", min: 0, max: 9, value: a, oninput: e => a.val = Number(e.target.value)}),
        " b: ",
        input({type: "number", min: 0, max: 9, value: b, oninput: e => b.val = Number(e.target.value)}),
        " c: ",
        input({type: "number", min: 0, max: 9, value: c, oninput: e => c.val = Number(e.target.value)}),
        " d: ",
        input({type: "number", min: 0, max: 9, value: d, oninput: e => d.val = Number(e.target.value)}),
      ),
      div("sum: ", () => {
        triggeredTimes.textContent = Number(triggeredTimes.textContent) + 1
        return formula.val === "a + b" ? a.val + b.val : c.val + d.val
      }),
      div("Binding function triggered: ", triggeredTimes, " time(s)"),
    )
  }

  van.add(document.getElementById("demo-conditional-binding"), ConditionalBinding())
}

{
  const {div, input, option, select} = van.tags

  const ConditionalDerive = () => {
    const formula = van.state("a + b")
    const a = van.state(1), b = van.state(2), c = van.state(3), d = van.state(4)
    const triggeredTimes = new Text(0)
    const sum = van.derive(() => {
      triggeredTimes.textContent = Number(triggeredTimes.textContent) + 1
      return formula.val === "a + b" ? a.val + b.val : c.val + d.val
    })

    return div(
      div(
        "formula: ",
        select({value: formula, oninput: e => formula.val = e.target.value},
          option("a + b"), option("c + d"),
        ),
        " a: ",
        input({type: "number", min: 0, max: 9, value: a, oninput: e => a.val = Number(e.target.value)}),
        " b: ",
        input({type: "number", min: 0, max: 9, value: b, oninput: e => b.val = Number(e.target.value)}),
        " c: ",
        input({type: "number", min: 0, max: 9, value: c, oninput: e => c.val = Number(e.target.value)}),
        " d: ",
        input({type: "number", min: 0, max: 9, value: d, oninput: e => d.val = Number(e.target.value)}),
      ),
      div("sum: ", sum),
      div("Binding function triggered: ", triggeredTimes, " time(s)"),
    )
  }

  van.add(document.getElementById("demo-conditional-derive"), ConditionalDerive())
}
</script>
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script type="text/javascript" src="/code/diff.min.js"></script>
    <script type="text/javascript" src="/code/van-latest.nomodule.min.js"></script>
    <script>
      const copy = e => {
        const file = e.previousElementSibling.innerText
        const importLine = file.includes("nomodule") ?
          `<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"><\/script>` :
          `import van from "https://cdn.jsdelivr.net/gh/vanjs-org/van/public/${file}"`
          navigator.clipboard.writeText(importLine)
            .then(() => e.querySelector(".tooltip").innerText = "Copied")
            .catch(() => e.querySelector(".tooltip").innerText = "Copy failed")
      }

      const resetTooltip = e => e.querySelector(".tooltip").innerText = "Copy import line"
    </script>
    <script class="inline"></script>
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async="" defer="" src="https://buttons.github.io/buttons.js"></script>
  

</body></html>